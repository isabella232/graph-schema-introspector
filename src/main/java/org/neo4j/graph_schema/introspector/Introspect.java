/*
 * Copyright (c) 2023 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.graph_schema.introspector;

import java.util.Map;
import java.util.stream.Stream;

import org.neo4j.graphdb.Transaction;
import org.neo4j.procedure.Context;
import org.neo4j.procedure.Description;
import org.neo4j.procedure.Mode;
import org.neo4j.procedure.Name;
import org.neo4j.procedure.Procedure;

import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * UDF for creating a Graph database schema according to the format defined here:
 * <a href="https://github.com/neo4j/graph-schema-json-js-utils">graph-schema-json-js-utils</a>, see scheme
 * <a href="https://github.com/neo4j/graph-schema-json-js-utils/blob/main/json-schema.json">here</a> and an example
 * <a href="https://github.com/neo4j/graph-schema-json-js-utils/blob/main/test/validation/test-schemas/full.json">here</a>.
 * <p>
 * The instrospector creates JSON ids based on the labels and types by default. It can alternatively use
 * Time-Sorted Unique Identifiers (TSID) for the ids inside the generated schema by calling it via
 * {@code CALL experimental.introspect.asJson({useConstantIds: false})}
 */
public class Introspect {

	static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
	static {
		OBJECT_MAPPER.registerModule(new GraphSchemaModule());
	}

	@Context
	public Transaction transaction;

	/**
	 * Shared configuration of the functions and procedures in this class.
	 *
	 * @param useConstantIds Whether to use constant ids (derived from tokens) or generate ids
	 * @param prettyPrint    Whether to pretty print the result or not
	 * @param quoteTokens    Whether to always quote tokens or not
	 */
	record Config(boolean useConstantIds, boolean prettyPrint, boolean quoteTokens) {

		Config(Map<String, Object> params) {
			this(
				(boolean) params.getOrDefault("useConstantIds", true),
				(boolean) params.getOrDefault("prettyPrint", false),
				(boolean) params.getOrDefault("quoteTokens", true)
			);
		}
	}

	@Procedure(name = "experimental.introspect.asJson", mode = Mode.READ)
	@Description("" +
		"Call with {useConstantIds: false} to generate substitute ids for all tokens and use {prettyPrint: true} for enabling pretty printing;" +
		"{quoteTokens: false} will disable quotation of tokens.")
	public Stream<GraphSchemaJSONResultWrapper> introspectAsJson(@Name("params") Map<String, Object> params) throws Exception {

		var config = new Config(params);
		var graphSchema = GraphSchema.from(transaction, config);

		var writer = config.prettyPrint() ? OBJECT_MAPPER.writerWithDefaultPrettyPrinter() : OBJECT_MAPPER.writer();
		return Stream.of(new GraphSchemaJSONResultWrapper(writer.writeValueAsString(graphSchema)));
	}

	@Procedure(name = "experimental.introspect.asGraph", mode = Mode.READ)
	@Description("Visualizes the JSON generated by this introspector in a graphy way")
	public Stream<GraphSchemaGraphyResultWrapper> introspectAndVisualize(@Name("params") Map<String, Object> params) throws Exception {

		var graphSchema = GraphSchema.from(transaction, new Config(params));
		return Stream.of(GraphSchemaGraphyResultWrapper.of(graphSchema));
	}
}
